#!/usr/bin/python3
import argparse
import os
import sys
import getpass

# Confirm that user is running python3
if sys.hexversion < 0x3000000:
    print("Please use python3")
    sys.exit(0)

# Attempt to import cryptography modules
try:
    from cryptography.hazmat.primitives.ciphers import Cipher
    from cryptography.hazmat.primitives.ciphers import algorithms
    from cryptography.hazmat.primitives.ciphers import modes
    from cryptography.hazmat.primitives import hashes, hmac
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
    from cryptography.hazmat.backends import default_backend
except ImportError:
    print("scrypto requires cryptography. Install with: "
          "pip3 install cryptography")
    sys.exit(0)

# Define crypto modules
CIPHERS = {
        'AES': algorithms.AES
}
MODES = {
        'CTR': modes.CTR,
        'CBC': modes.CBC
}
HASHERS = {
        'SHA512': hashes.SHA512(),
        'SHA256': hashes.SHA256(),
        'BLAKE2': hashes.BLAKE2b(64),
}


class CryptoError(Exception):
    """Exception raised for errors related to message decryption"""
    def __init__(self, message):
        self.message = message


class Crypto(object):
    """Handles all cryptographic operations"""
    def __init__(self, cipher, mode, hasher, password, salt=None, nonce=None):

        self.hasher = HASHERS[hasher]
        self.salt = salt or self.get_random_bytes(16)
        key = self.derive_key(password)
        self.key_hash = self.hash(key)
        self.cipher_key = key[:16]
        self.mac_key = key[16:]
        self.nonce = nonce or self.get_random_bytes(16)
        self.cipher = Cipher(CIPHERS[cipher](self.cipher_key),
                             MODES[mode](self.nonce),
                             backend=default_backend())

    def get_random_bytes(self, n):
        """Returns n bytes of randomness"""
        return os.urandom(n)

    def constant_time_comparison(self, str1, str2):
        """Compares two strings in constant times to avoid timing attacks"""
        if len(str1) != len(str2):
            raise CryptoError("File is of incorrect format")
        is_equal = True
        for a, b in zip(str1, str2):
            if a != b:
                is_equal = False
        return is_equal

    def verify_integrity(self, key_hash, enc_content, tag):
        """Verifies password hash and HMAC tag on ciphertext"""
        # Check if password is correct
        if not self.constant_time_comparison(self.key_hash, key_hash):
            raise CryptoError("Invalid password or file has been modified")

        # Confirm HMAC is valid
        calc_mac = self.HMAC(enc_content)
        if not self.constant_time_comparison(tag, calc_mac):
            raise CryptoError("File has been tampered with")

    def derive_key(self, password):
        """Runs PBKDF2 with 100000 iterations on provided password"""
        # You'll probably want to change the iteration count to something
        # smaller.
        # Using SHA256 to avoid https://eprint.iacr.org/2016/273.pdf
        kdf = PBKDF2HMAC(self.hasher,
                         length=32,
                         salt=self.salt,
                         iterations=300000,
                         backend=default_backend()
                         )
        key = kdf.derive(password)
        return key

    def hash(self, msg):
        """Computes the hash of a given msg"""
        hasher = hashes.Hash(self.hasher, backend=default_backend())
        hasher.update(msg)
        return hasher.finalize()

    def HMAC(self, msg):
        """Computes the HMAC of given message using given key and hash"""
        HMACger = hmac.HMAC(self.mac_key,
                            self.hasher,
                            backend=default_backend())
        HMACger.update(msg)
        return HMACger.finalize()

    def aes_encrypt(self, plaintext):
        """Encrypts data using AES-CTR with provided key and data"""
        encryptor = self.cipher.encryptor()
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        return ciphertext

    def aes_decrypt(self, ciphertext):
        """Decrypts ciphertext using AES-CTR with provided key and nonce"""
        decryptor = self.cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        return plaintext


class FileHandler(object):
    """Responsible for creating and parsing all files"""
    def __init__(self, content, cwd, operation, filename=None):
        self.content = content
        self.cwd = cwd
        self.operation = operation
        self.name = filename

    def write(self):
        if self.operation == "Encrypt":
            with open(self.cwd + '/' + self.name + '.enc', 'bw') as f:
                f.write(self.to_write)
                print("File: {} encrypted!".format(self.name))
        else:  # Better system here pls
            with open(self.cwd + '/' + self.name, 'bw') as f:
                f.write(self.to_write)
                print("File: {} decrypted!".format(self.name))

    def generate_enc_file(self, crypto):
        """Returns all elements concatenated together and HMACged correctly"""
        # Forward slashes are banned in filenames so use that as a separator
        enc_content = (bytes(self.name, 'utf-8') + b"/" + crypto.nonce +
                       self.content)

        # Compute HMAC
        tag = crypto.HMAC(enc_content)
        self.name = self.name.split(".")[0]
        self.to_write = crypto.salt + crypto.key_hash + tag + enc_content

    def decode_file(self, password):
        """Parses an encrypted file into the corresponding crypto object"""
        # Extract all components of file
        try:
            salt = self.content[:16]
            key_hash = self.content[16:48]
            tag = self.content[48:80]
            enc_content = self.content[80:]

            self.name = str(enc_content.split(b"/")[0], 'utf-8')
            # There's an extra +1 because of the forward slash
            nonce = enc_content[len(self.name)+1:len(self.name)+17]
            ciphertext = enc_content[len(self.name)+17:]
        except IndexError:
            raise CryptoError("File has been tampered with")

        # Generate crypto object and verify integrity
        crypto = Crypto("AES", "CTR", "SHA256", password, salt, nonce)
        crypto.verify_integrity(key_hash, enc_content, tag)
        return crypto, ciphertext

    def get_files(cwd, filenames, remove):
        """Return a list containing tuples of all filenames and plaintexts"""
        files = []
        for filename in filenames:
            try:
                file = open(cwd + '/' + filename, 'rb')
                # Each element is a tuple of filename and contents
                files.append((filename, file.read()))
                file.close()
            except IOError:
                    print("Given file: " + filename +
                          " does not exist. Skipping")

            # Delete the original file if the option was set by user
            if remove:
                os.remove(cwd + '/' + filename)
        return files


def make_parser():
    """Builds ArgumentParser Object"""
    parser = argparse.ArgumentParser(description='Encrypt files using 128-bit '
                                     'AES')
    parser.add_argument('filenames', nargs='+',
                        help='Files to encrypt/decrypt (Default is encrypt)',
                        type=str)
    parser.add_argument('-d', '--decrypt', required=False,
                        action='store_true',
                        help='Decrypt file')
    parser.add_argument('-r', '--remove', required=False,
                        action='store_true',
                        help='Remove original file')
    return parser


def encryptor(password, cwd, file):
    """Encrypts the given file with the given password"""
    filename, plaintext = file
    crypto = Crypto("AES", "CTR", "SHA256", password)
    ciphertext = crypto.aes_encrypt(plaintext)
    file_handler = FileHandler(ciphertext, cwd, "Encrypt", filename)
    file_handler.generate_enc_file(crypto)
    file_handler.write()


def decryptor(password, cwd, file):
    """Decrypts the given file with the given password"""
    _, enc_file = file
    file_handler = FileHandler(enc_file, cwd, "Decrypt")
    crypto, ciphertext = file_handler.decode_file(password)

    # Decrypt file and write to the original filename
    plaintext = crypto.aes_decrypt(ciphertext)
    file_handler.to_write = plaintext
    file_handler.write()


if __name__ == "__main__":
    # Get arguments and files
    cwd = os.getcwd()
    args = make_parser().parse_args()
    filenames = args.filenames
    remove = args.remove
    decrypt = args.decrypt
    password = bytes(getpass.getpass(), 'utf-8')
    files = FileHandler.get_files(cwd, filenames, remove)

    # Set modifer/writer functios depending on user-requested action
    if decrypt:
        # Function to apply to file contents
        modifier = decryptor
    else:
        # Function to apply to file contents
        modifier = encryptor

    # Encrypt/decrypt each file
    for file in files:
        modifier(password, cwd, file)
