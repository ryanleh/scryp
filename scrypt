#!/usr/bin/python3
import argparse
import os
import binascii
import json
import getpass
from Crypto.Cipher import AES
from Crypto.Hash import HMAC, SHA256
from Crypto.Protocol.KDF import PBKDF2
from Crypto import Random
from Crypto.Util import Counter

class CryptoError(Exception):
    """Exception raised for errors related to message decryption"""
    def __init__(self, message):
        self.message = message


def make_parser():
    """Builds ArgumentParser Object"""
    parser = argparse.ArgumentParser(description=
                                     'Encrypt files using 128-bit AES')
    parser.add_argument('filenames', nargs='+',
                        help='Files to encrypt/decrypt (Default is encrypt)',
                        type=str)
    parser.add_argument('-d', '--decrypt', required=False,
                        action='store_true',
                        help='Decrypt file')
    parser.add_argument('-r', '--remove', required=False,
                        action='store_true',
                        help='Remove original file')
    return parser


def get_random_bytes(n):
    """Returns n bytes of randomness"""
    return Random.new().read(n)


def password_to_key(password, salt=None):
    """Runs PBKDF2 with 100000 iterations on provided password.

    Params:
      *  password (str): Password provided by user

    Returns:
      *  salt (byte str): random 8-bytes
      *  key (byte str): Result of PBKDF2 function on user's password
    """
    # 8-byte random salt
    if not salt:
        salt = get_random_bytes(8)
    # You'll probably want to change the iteration count to something smaller
    key = PBKDF2(password, salt, dkLen=16, count=100000,
                 prf=lambda key, salt: HMAC.new(key, salt, SHA256).digest())
    return salt, key


def hash_key(key):
    """Hashes given key with one iteration of SHA256 and returns result

    Params:
      *  key (byte str): Result of PBKDF2 function on user's password

    Returns:
      *  key_hash (byte str)
    """
    return SHA256.SHA256Hash(key).digest()


def aes_encrypt(key, data):
    """Encrypts data using AES-CTR with provided key and data

    Params:
      *  key (byte str): Result of PBKDF2 function on user's password
      *  data (byte str): byte encoding of file contents

    Returns:
      *  iv (byte str): 8-bytes of randomness
      *  encrypted_data (byte str): Result of AES-CTR
    """
    iv = get_random_bytes(8)
    # Generate a new counter object for CTR mode
    counter = Counter.new(64, initial_value=1, prefix=iv)
    cipher = AES.new(key, AES.MODE_CTR, counter=counter)
    return iv, cipher.encrypt(data)


def aes_decrypt(key, iv, ciphertext):
    """Encrypts data using AES-CTR with provided key and data"""
    # Generate a new counter object for CTR mode
    counter = Counter.new(64, initial_value=1, prefix=iv)
    cipher = AES.new(key, AES.MODE_CTR, counter=counter)
    try:
        return cipher.decrypt(ciphertext)
    # TODO: Check to make sure that PyCrypto actually throws a ValueError
    except ValueError:
        raise CryptoError("Decryption failed")


def get_files(cwd, filenames, remove, processor):
    """Return a list containing tuples of all filenames and plaintexts"""
    # Populate plaintexts from files
    files = []
    for filename in filenames:
        try:
            file = open(cwd + '/' + filename, 'br')
            # Each element is a tuple of filename and plaintext
            files.append((filename, processor(file.read())))
            file.close()
        except IOError:
                print("Given file: " + filename + " does not exist. Skipping")
        # Delete the original file if the option was set by user
        if remove:
            os.remove(cwd + '/' + filename)
    return files


def encryptor(password, file):
    """Encrypts the given file with the given password"""
    # Generate salt, key, and key hash
    salt, key = password_to_key(password)
    key_hash = hash_key(key)
    cipher_key = key[:16]
    mac_key = key[16:]
    # Encrypt the plaintext
    iv, ciphertext = aes_encrypt(cipher_key, file[1])
    # Convert necessary values to hex and dump in a json object
    # TODO: Figure out if we want to keep utf-8 in some parts
    value = bytes(json.dumps({
            'filename': bytes(file[0], 'unicode_escape').hex(),
            'iv': iv.hex(),
            'ciphertext': ciphertext.hex()
            }), 'unicode_escape')
    # Compute MAC
    mac = HMAC.HMAC(mac_key, value, SHA256.SHA256Hash()).digest()
    # Concatenate all necessary elements
    return file[0], salt + key_hash + mac + value


def decryptor(password, file):
    """Decrypts the given file with the given password"""
    ciphertext = file[1]
    # Extract salt and key_hash to check if key is valid
    salt = ciphertext[:8]
    key_hash = ciphertext[8:40]
    given_key = password_to_key(password, salt)[1]
    if hash_key(given_key) != key_hash:
        raise CryptoError("Invalid password")
    # Extract remaining values and make sure MAC is valid
    cipher_key = given_key[:16]
    mac_key = given_key[16:]
    mac = ciphertext[40:72]
    value = ciphertext[72:]
    calc_mac = HMAC.HMAC(mac_key, value, SHA256.SHA256Hash()).digest()
    if mac != calc_mac:
        raise CryptoError("Message has been tampered with")
    value = json.loads(str(value, 'unicode_escape'))
    # Decrypt file and write to the original filename
    filename = str(binascii.unhexlify(value['filename']), 'unicode_escape')
    plaintext = aes_decrypt(cipher_key, binascii.unhexlify(value['iv']),
                            binascii.unhexlify(value['ciphertext']))
    return filename, plaintext


if __name__ == "__main__":
    # Get arguments
    cwd = os.getcwd()
    args = make_parser().parse_args()
    filenames = args.filenames
    remove = args.remove
    decrypt = args.decrypt
    password = getpass.getpass()
    # TODO: this work for now but make it work with things other than text
    if decrypt:
        # Function to process input files
        def processor(input):
            return binascii.unhexlify(input.strip())
        # Function to apply to file contents
        modifier = decryptor
        # Function to write file
        def writer(filename, plaintext):
            with open(cwd + '/' + filename, 'w') as f:
                f.write(str(plaintext, 'unicode_escape'))
            print("File: " + filename + " decrypted!")
    else:
        # Function to process input files
        def processor(input):
            return bytes(input, 'unicode_escape')
        # Function to apply to file contents
        modifier = encryptor
        # Function to write file
        def writer(filename, ciphertext):
            with open(cwd + '/' + filename + '.enc', 'bw') as f:
                f.write(binascii.hexlify(ciphertext))
                f.write(b"\n")
            print("File: " + filename + " encrypted!")
    files = get_files(cwd, filenames, remove, processor)

    # From each plaintexts create a .enc file
    for file in files:
        writer(*modifier(password, file))
