#!/usr/bin/python3
import argparse
import os
import binascii
import json
import getpass
from Crypto.Cipher import AES
from Crypto.Hash import HMAC, SHA256
from Crypto.Protocol.KDF import PBKDF2
from Crypto import Random
from Crypto.Util import Counter

class CryptoError(Exception):
    """Exception raised for errors related to message decryption"""
    def __init__(self, message):
        self.message = message


def make_parser():
    """Builds ArgumentParser Object"""
    parser = argparse.ArgumentParser(description=
                                     'Encrypt files using 128-bit AES')
    parser.add_argument('filenames', nargs='+',
                        help='Files to encrypt/decrypt (Default is encrypt)',
                        type=str)
    parser.add_argument('-d', '--decrypt', required=False,
                        action='store_true',
                        help='Decrypt file')
    parser.add_argument('-r', '--remove', required=False,
                        action='store_true',
                        help='Remove original file')
    return parser


def get_random_bytes(n):
    """Returns n bytes of randomness"""
    return Random.new().read(n)


def constant_time_comparison(str1, str2):
    """Compares two strings in constant times to avoid timing attacks"""
    if len(str1) != len(str2):
        raise CryptoError("File is incorrect format")
    is_equal = True
    for a, b in zip(str1, str2):
        if a != b:
            is_equal = False
    return is_equal


def password_to_key(password, salt=None):
    """Runs PBKDF2 with 100000 iterations on provided password.

    Params:
      *  password (str): Password provided by user

    Returns:
      *  salt (byte str): random 8-bytes
      *  key (byte str): Result of PBKDF2 function on user's password
    """
    # 8-byte random salt
    if not salt:
        salt = get_random_bytes(8)
    # You'll probably want to change the iteration count to something smaller
    key = PBKDF2(password, salt, dkLen=32, count=100000,
                 prf=lambda key, salt: HMAC.new(key, salt, SHA256).digest())
    return salt, key


def hash_key(key):
    """Hashes given key with one iteration of SHA256 and returns result

    Params:
      *  key (byte str): Result of PBKDF2 function on user's password

    Returns:
      *  key_hash (byte str)
    """
    return SHA256.SHA256Hash(key).digest()


def aes_encrypt(key, data):
    """Encrypts data using AES-CTR with provided key and data

    Params:
      *  key (byte str): Result of PBKDF2 function on user's password
      *  data (byte str): byte encoding of file contents

    Returns:
      *  nonce (byte str): 8-bytes of randomness
      *  encrypted_data (byte str): Result of AES-CTR
    """
    nonce = get_random_bytes(12)
    # Generate a new counter object for CTR mode
    counter = Counter.new(32, initial_value=1, prefix=nonce)
    cipher = AES.new(key, AES.MODE_CTR, counter=counter)
    return nonce, cipher.encrypt(data)


def aes_decrypt(key, nonce, ciphertext):
    """Encrypts data using AES-CTR with provided key and data"""
    # Generate a new counter object for CTR mode
    counter = Counter.new(32, initial_value=1, prefix=nonce)
    cipher = AES.new(key, AES.MODE_CTR, counter=counter)
    try:
        return cipher.decrypt(ciphertext)
    # TODO: Check to make sure that PyCrypto actually throws a ValueError
    except ValueError:
        raise CryptoError("Decryption failed")


def get_files(cwd, filenames, remove, processor):
    """Return a list containing tuples of all filenames and plaintexts"""
    # Populate plaintexts from files
    files = []
    for filename in filenames:
        try:
            file = open(cwd + '/' + filename, 'rb')
            # Each element is a tuple of filename and plaintext
            files.append((filename, processor(file.read())))
            file.close()
        except IOError:
                print("Given file: " + filename + " does not exist. Skipping")
        # Delete the original file if the option was set by user
        if remove:
            os.remove(cwd + '/' + filename)
    return files


def encryptor(password, file):
    """Encrypts the given file with the given password"""
    # Generate salt, key, and key hash
    salt, key = password_to_key(password)
    key_hash = hash_key(key)
    cipher_key = key[:16]
    mac_key = key[16:]
    # Encrypt the plaintext
    nonce, ciphertext = aes_encrypt(cipher_key, file[1])
    # Forward shalshes aren't allowed in filenames so use that to differentiate
    encrypted_file = bytes(file[0], 'utf-8') + b"/" + nonce + ciphertext
    # Compute MAC
    mac = HMAC.HMAC(mac_key, encrypted_file, SHA256.SHA256Hash()).digest()
    # Concatenate all necessary elements
    return file[0], salt + key_hash + mac + encrypted_file


def decryptor(password, file):
    """Decrypts the given file with the given password"""
    ciphertext = file[1]
    # Extract salt and key_hash to check if key is valid
    salt = ciphertext[:8]
    key_hash = ciphertext[8:40]
    given_key = password_to_key(password, salt)[1]
    if not constant_time_comparison(hash_key(given_key), key_hash):
        raise CryptoError("Invalid password")
    # Extract remaining values and make sure MAC is valid
    cipher_key = given_key[:16]
    mac_key = given_key[16:]
    mac = ciphertext[40:72]
    encrypted_file = ciphertext[72:]
    calc_mac = HMAC.HMAC(mac_key, encrypted_file, SHA256.SHA256Hash()).digest()
    # TODO: constant time comparison
    if not constant_time_comparison(mac, calc_mac):
        raise CryptoError("Message has been tampered with")
    # Extract filename, nonce, and ciphertext
    filename = encrypted_file.split(b"/")[0]
    # There's an extra +1 because of the forward slash
    nonce = encrypted_file[len(filename)+1:len(filename)+13]
    ciphertext = encrypted_file[len(filename)+13:]
    # Decrypt file and write to the original filename
    filename = str(filename, 'utf-8')
    plaintext = aes_decrypt(cipher_key, nonce, ciphertext)
    return filename, plaintext


if __name__ == "__main__":
    # Get arguments
    cwd = os.getcwd()
    args = make_parser().parse_args()
    filenames = args.filenames
    remove = args.remove
    decrypt = args.decrypt
    password = getpass.getpass()
    if decrypt:
        # Function to process input files
        def processor(input):
            return input.strip()
        # Function to apply to file contents
        modifier = decryptor
        # Function to write file
        def writer(filename, plaintext):
            with open(cwd + '/' + filename, 'bw') as f:
                f.write(plaintext)
            print("File: " + filename + " decrypted!")
    else:
        # Function to process input files
        def processor(input):
            return input
        # Function to apply to file contents
        modifier = encryptor
        # Function to write file
        def writer(filename, ciphertext):
            with open(cwd + '/' + filename + '.enc', 'bw') as f:
                f.write(ciphertext)
                f.write(b"\n")
            print("File: " + filename + " encrypted!")
    files = get_files(cwd, filenames, remove, processor)

    # From each plaintexts create a .enc file
    for file in files:
        writer(*modifier(password, file))
