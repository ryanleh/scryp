#!/usr/bin/python3
import argparse
import os
import binascii
import json
import getpass
from Crypto.Cipher import AES
from Crypto.Hash import HMAC, SHA256
from Crypto.Protocol.KDF import PBKDF2
from Crypto import Random
from Crypto.Util import Counter

class CryptoError(Exception):
    """Exception raised for errors related to message decryption"""
    def __init__(self, message):
        self.message = message

def make_parser():
    """Builds ArgumentParser Object"""
    parser = argparse.ArgumentParser(description=
                                     'Decrypt files using 128-bit AES')
    parser.add_argument('filenames', nargs='+', help='Files to decrypt',
                        type=str)
    parser.add_argument('-r', '--remove', required=False,
                        action='store_true',
                        help='Delete ciphertext file')
    return parser

def password_to_key(password, salt):
    """Runs PBKDF2 with 100000 iterations on provided password.

    Params:
      *  password (str): Password provided by user
      *  salt (byte str): Salt given by file

    Returns:
      *  key (byte str): Result of PBKDF2 function on user's password
    """
    key = PBKDF2(password, salt, dkLen=16, count=100000,
                 prf=lambda key, salt: HMAC.new(key, salt, SHA256).digest())
    return key

def hash_key(key):
    """Hashes given key with one iteration of SHA256 and returns result

    Params:
      *  key (byte str): Result of PBKDF2 function on user's password

    Returns:
      *  key_hash (byte str)
    """
    return SHA256.SHA256Hash(key).digest()

def decrypt_file(key, iv, ciphertext):
    """Encrypts data using AES-CTR with provided key and data"""
    # Generate a new counter object for CTR mode
    counter = Counter.new(64, initial_value=1, prefix=iv)
    cipher = AES.new(key, AES.MODE_CTR, counter=counter)
    try:
        return cipher.decrypt(ciphertext)
    except:
        raise CryptoError("Decryption failed")

def get_files(cwd, filenames):
    """Return a list containing all ciphertexts from files"""
    # Populate ciphertexts from files
    ciphertexts = []
    for filename in filenames:
        try:
            file = open(cwd + '/' + filename, 'r')
            try:
                file_contents = binascii.unhexlify(file.read().strip())
            except binascii.Error:
                raise CryptoError("Invalid ciphertext")
            file.close()
        except IOError:
            print("Given file: " + filename + " does not exist. Skipping")
        ciphertexts.append(file_contents)
        # Delete the .enc file if the option was set by user
        if remove_ct:
            os.remove(cwd + '/' + filename)
    return ciphertexts

if __name__ == "__main__":
    # Get arguments
    cwd = os.getcwd()
    args = make_parser().parse_args()
    filenames = args.filenames
    remove_ct = args.remove
    password = getpass.getpass()
    ciphertexts = get_files(cwd, filenames)
    for ciphertext in ciphertexts:
        # Extract salt and key_hash to check if key is valid
        salt = ciphertext[:8]
        key_hash = ciphertext[8:40]
        given_key = password_to_key(password, salt)
        if hash_key(given_key) != key_hash:
            raise CryptoError("Invalid password")
        # Extract remaining values and make sure MAC is valid
        cipher_key = given_key[:16]
        mac_key = given_key[16:]
        iv = ciphertext[40:48]
        mac = ciphertext[48:80]
        value = ciphertext[80:]
        calc_mac = HMAC.HMAC(mac_key, value, SHA256.SHA256Hash()).digest()
        if mac != calc_mac:
            raise CryptoError("Message has been tampered with")
        value = json.loads(str(value, 'utf-8'))
        # Decrypt file and write to the original filename
        filename = str(binascii.unhexlify(value['filename']), 'utf-8')
        plaintext = decrypt_file(cipher_key, binascii.unhexlify(value['iv']),
                                 binascii.unhexlify(value['ciphertext']))
        new_file = open(cwd + '/' + filename, 'w')
        new_file.write(str(plaintext, 'utf-8'))
        new_file.close()
        print("File: " + filename + " decrypted!")
