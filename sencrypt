#!/usr/bin/python3
import argparse
import os
import binascii
import json
import getpass
from Crypto.Cipher import AES
from Crypto.Hash import HMAC, SHA256
from Crypto.Protocol.KDF import PBKDF2
from Crypto import Random
from Crypto.Util import Counter

def make_parser():
    """Builds ArgumentParser Object"""
    parser = argparse.ArgumentParser(description=
                                     'Encrypt files using 128-bit AES')
    parser.add_argument('filenames', nargs='+', help='Files to encrypt',
                        type=str)
    parser.add_argument('-o', '--overwrite', required=False,
                        action='store_true',
                        help='Whether to delete original file')
    return parser

def get_random_bytes(n):
    """Returns n bytes of randomness"""
    return Random.new().read(n)

def generate_salt():
    """Generate an n-byte alnum salt with 190 bits of entropy"""
    alnum = ''.join(c for c in map(chr, range(256)) if c.isalnum())
    return ''.join(random.choice(alnum) for _ in range(32))

def password_to_key(password):
    """Runs PBKDF2 with 100000 iterations on provided password.

    Params:
      *  password (str): Password provided by user

    Returns:
      *  salt (byte str): random 8-bytes
      *  key (byte str): Result of PBKDF2 function on user's password
    """
    # 8-byte random salt
    salt = get_random_bytes(8)
    # You'll probably want to change the iteration count to something smaller
    key = PBKDF2(password, salt, dkLen=16, count=100000,
                 prf=lambda key, salt: HMAC.new(key, salt, SHA256).digest())
    return salt, key

def hash_key(key):
    """Hashes given key with one iteration of SHA256 and returns result

    Params:
      *  key (byte str): Result of PBKDF2 function on user's password

    Returns:
      *  key_hash (byte str)
    """
    return SHA256.SHA256Hash(key).digest()

def aes_encrypt(key, data):
    """Encrypts data using AES-CTR with provided key and data

    Params:
      *  key (byte str): Result of PBKDF2 function on user's password
      *  data (byte str): byte encoding of file contents

    Returns:
      *  iv (byte str): 8-bytes of randomness
      *  encrypted_data (byte str): Result of AES-CTR
    """
    iv = get_random_bytes(8)
    # Generate a new counter object for CTR mode
    counter = Counter.new(64, initial_value=1, prefix=iv)
    cipher = AES.new(key, AES.MODE_CTR, counter=counter)
    return iv, cipher.encrypt(data)

def get_files(cwd, filenames):
    """Return a list containing tuples of all filenames and plaintexts"""
            try:
            file = open(cwd + '/' + filename, 'r')
            # Each element is a tuple of filename and plaintext
            plaintexts.append((filename,
                               bytes(file.read(), 'utf-8')))
            file.close()
        except IOError:
                print("Given file: " + filename + " does not exist. Skipping")
        # Delete the original file if the option was set by user
        if overwrite:
            os.remove(cwd + '/' + filename)
    return plaintexts

def enc_file(plaintexts, password, key):
    """Encrypt the given plaintexts"""
    return None

def write_file();
    """Write the given file """
    return None


if __name__ == "__main__":
    # Get arguments
    cwd = os.getcwd()
    args = make_parser().parse_args()
    filenames = args.filenames
    overwrite = args.overwrite
    password = getpass.getpass()
    plaintexts = get_files(cwd, filenames)
    # Populate plaintexts from files
    plaintexts = []
    for filename in filenames:
        plaintexts.append(get_files(cwd, filename))

    # From each plaintexts create a .enc file
    for plaintext in plaintexts:
        # Generate salt, key, and key hash
        salt, key = password_to_key(password)
        key_hash = hash_key(key)
        cipher_key = key[:16]
        mac_key = key[16:]
        # Encrypt the plaintext
        iv, ciphertext = aes_encrypt(cipher_key, plaintext[1])
        # Convert necessary values to hex and dump in a json object
        value = bytes(json.dumps({
                 'filename': bytes(plaintext[0], 'utf-8').hex(),
                 'iv': iv.hex(),
                 'ciphertext': ciphertext.hex()
        }), 'utf-8')
        # Compute MAC
        mac = HMAC.HMAC(mac_key, value, SHA256.SHA256Hash()).digest()
        # Concatenate all necessary elements
        to_write = salt + key_hash + iv + mac + value
        new_file = open(cwd + '/' + plaintext[0] + '.enc', 'bw')
        new_file.write(binascii.hexlify(to_write))
        new_file.write(bytes("\n", 'utf-8'))
        new_file.close()
        print("File: " + plaintext[0] + " encrypted!")
